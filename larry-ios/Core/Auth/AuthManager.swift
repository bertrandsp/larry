//
//  AuthManager.swift
//  larry-ios
//
//  Created by AI Assistant on 9/15/25.
//

import Foundation
import AuthenticationServices
import SwiftUI
import UIKit
// import GoogleSignIn // TODO: Add GoogleSignIn dependency to Xcode project
// import KeychainAccess // TODO: Add KeychainAccess dependency to Xcode project
import Combine

/// Manages user authentication state and operations
@MainActor
class AuthManager: NSObject, ObservableObject {
    static let shared = AuthManager()
    
    // MARK: - Published Properties
    
    @Published var isAuthenticated = false
    @Published var currentUser: User?
    @Published var authState: AuthState = .idle
    
    // MARK: - Private Properties
    
    // TODO: Replace with KeychainAccess when dependency is added
    private let userDefaults = UserDefaults.standard
    private var cancellables = Set<AnyCancellable>()
    
    // App lifecycle monitoring
    @Published var isValidatingUser = false
    
    // MARK: - Keychain Keys
    
    private enum KeychainKeys {
        static let accessToken = "access_token"
        static let refreshToken = "refresh_token"
        static let userID = "user_id"
    }
    
    // MARK: - Authentication State
    
    enum AuthState: Equatable {
        case idle
        case signingIn
        case refreshingToken
        case signingOut
        case validatingUser
        case error(String) // Changed from Error to String for Equatable conformance
        
        var isLoading: Bool {
            switch self {
            case .signingIn, .refreshingToken, .signingOut, .validatingUser:
                return true
            default:
                return false
            }
        }
        
        static func == (lhs: AuthState, rhs: AuthState) -> Bool {
            switch (lhs, rhs) {
            case (.idle, .idle),
                 (.signingIn, .signingIn),
                 (.refreshingToken, .refreshingToken),
                 (.signingOut, .signingOut),
                 (.validatingUser, .validatingUser):
                return true
            case (.error(let lhsError), .error(let rhsError)):
                return lhsError == rhsError
            default:
                return false
            }
        }
    }
    
    // MARK: - Token Properties
    
    var accessToken: String? {
        return userDefaults.string(forKey: KeychainKeys.accessToken)
    }
    
    private var refreshTokenValue: String? {
        return userDefaults.string(forKey: KeychainKeys.refreshToken)
    }
    
    // MARK: - Initialization
    
    private override init() {
        super.init()
        checkAuthenticationState()
        setupAppLifecycleMonitoring()
        
        #if DEBUG
        print("üîê AuthManager initialized")
        #endif
    }
    
    // MARK: - Authentication State Management
    
    private func checkAuthenticationState() {
        #if DEBUG
        print("üîç ===== CHECKING AUTHENTICATION STATE =====")
        print("üîç Current state before check:")
        print("üîç   - isAuthenticated: \(isAuthenticated)")
        print("üîç   - currentUser: \(currentUser?.email ?? "nil")")
        print("üîç   - authState: \(authState)")
        #endif
        
        // Force clear any existing state first
        isAuthenticated = false
        currentUser = nil
        
        if let token = accessToken, !token.isEmpty {
            #if DEBUG
            print("üîë Found access token: \(token.prefix(10))...")
            print("üîë Token length: \(token.count) characters")
            #endif
            
            // Validate token by fetching user profile
            Task {
                await fetchUserProfile()
            }
        } else {
            #if DEBUG
            print("‚ùå No access token found")
            print("‚ùå Access token value: \(accessToken ?? "nil")")
            print("‚ùå Setting authenticated = false")
            #endif
            isAuthenticated = false
            currentUser = nil
        }
        
        #if DEBUG
        print("üîê Final auth state after check:")
        print("üîê   - isAuthenticated: \(isAuthenticated)")
        print("üîê   - currentUser: \(currentUser?.email ?? "nil")")
        print("üîê   - authState: \(authState)")
        print("üîê ===== AUTHENTICATION STATE CHECK COMPLETE =====")
        #endif
    }
    
    // MARK: - Sign In with Apple
    
    func handleAppleSignInResult(_ authorization: ASAuthorization) async throws {
        #if DEBUG
        print("üçé ===== APPLE SIGN IN STARTED =====")
        #endif
        
        authState = .signingIn
        
        do {
            guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential,
                  let identityTokenData = appleIDCredential.identityToken,
                  let identityToken = String(data: identityTokenData, encoding: .utf8),
                  let authorizationCodeData = appleIDCredential.authorizationCode,
                  let authorizationCode = String(data: authorizationCodeData, encoding: .utf8) else {
                #if DEBUG
                print("üçé ‚ùå Failed to extract Apple credentials")
                #endif
                throw AuthError.appleSignInFailed
            }
            
            #if DEBUG
            print("üçé ‚úÖ Apple credentials extracted successfully")
            print("üçé   - Email: \(appleIDCredential.email ?? "nil")")
            print("üçé   - User ID: \(appleIDCredential.user)")
            print("üçé   - Identity token length: \(identityToken.count)")
            print("üçé   - Authorization code length: \(authorizationCode.count)")
            #endif
            
            // Send Apple credentials to backend
            let authRequest = AppleAuthRequest(
                identityToken: identityToken,
                authorizationCode: authorizationCode,
                fullName: appleIDCredential.fullName,
                email: appleIDCredential.email
            )
            
            #if DEBUG
            print("üçé Making API request to: /auth-direct/apple")
            #endif
            
            let apiRequest = try APIRequest(
                method: .POST,
                path: "/auth-direct/apple",
                body: authRequest
            )
            
            let response: AuthResponse = try await APIService.shared.send(
                apiRequest,
                responseType: AuthResponse.self
            )
            
            #if DEBUG
            print("üçé ‚úÖ API call successful!")
            print("üçé   - Access token received: \(response.accessToken.prefix(10))...")
            print("üçé   - User: \(response.user?.email ?? "nil")")
            #endif
            
            await handleSuccessfulAuth(response)
            
            #if DEBUG
            print("üçé ===== APPLE SIGN IN SUCCESSFUL =====")
            #endif
            
        } catch {
            #if DEBUG
            print("üçé ‚ùå ===== APPLE SIGN IN FAILED =====")
            print("üçé Error details:")
            print("üçé   - Error type: \(type(of: error))")
            print("üçé   - Error description: \(error.localizedDescription)")
            print("üçé   - Full error: \(error)")
            #endif
            
            authState = .error(error.localizedDescription)
            throw error
        }
    }
    
    // MARK: - Sign In with Google
    
    func signInWithGoogle() async throws {
        // TODO: Implement Google Sign-In when GoogleSignIn dependency is added
        throw AuthError.googleSignInFailed
    }
    
    // MARK: - Token Refresh
    
    func refreshToken() async throws {
        guard let refreshToken = refreshTokenValue else {
            throw AuthError.noRefreshToken
        }
        
        authState = .refreshingToken
        
        do {
            let request = RefreshTokenRequest(refreshToken: refreshToken)
            let apiRequest = try APIRequest(
                method: .POST,
                path: "/auth-direct/refresh",
                body: request
            )
            
            let response: AuthResponse = try await APIService.shared.send(
                apiRequest,
                responseType: AuthResponse.self
            )
            
            // Store new tokens
            userDefaults.set(response.accessToken, forKey: KeychainKeys.accessToken)
            if let newRefreshToken = response.refreshToken {
                userDefaults.set(newRefreshToken, forKey: KeychainKeys.refreshToken)
            }
            
            authState = .idle
            
            #if DEBUG
            print("‚úÖ Token refreshed successfully")
            #endif
            
        } catch {
            authState = .error(error.localizedDescription)
            await logout() // Force logout on refresh failure
            throw error
        }
    }
    
    // MARK: - Logout
    
    func logout() async {
        #if DEBUG
        print("üëã ===== LOGGING OUT USER =====")
        print("üëã Current state before logout:")
        print("üëã   - isAuthenticated: \(isAuthenticated)")
        print("üëã   - currentUser: \(currentUser?.email ?? "nil")")
        print("üëã   - authState: \(authState)")
        #endif
        
        authState = .signingOut
        
        // Clear stored tokens
        userDefaults.removeObject(forKey: KeychainKeys.accessToken)
        userDefaults.removeObject(forKey: KeychainKeys.refreshToken)
        userDefaults.removeObject(forKey: KeychainKeys.userID)
        
        // Clear state
        isAuthenticated = false
        currentUser = nil
        authState = .idle
        
        // Sign out from Google if needed
        // TODO: Uncomment when GoogleSignIn dependency is added
        // GIDSignIn.sharedInstance.signOut()
        
        #if DEBUG
        print("üëã ‚úÖ User logged out successfully")
        print("üëã Final state after logout:")
        print("üëã   - isAuthenticated: \(isAuthenticated)")
        print("üëã   - currentUser: \(currentUser?.email ?? "nil")")
        print("üëã   - authState: \(authState)")
        print("üëã ===== LOGOUT COMPLETE =====")
        #endif
    }
    
    // MARK: - Clear All Auth Data (for debugging/testing)
    
    func clearAllAuthData() {
        #if DEBUG
        print("üßπ Clearing all authentication data...")
        #endif
        
        // Clear stored tokens
        userDefaults.removeObject(forKey: KeychainKeys.accessToken)
        userDefaults.removeObject(forKey: KeychainKeys.refreshToken)
        userDefaults.removeObject(forKey: KeychainKeys.userID)
        
        // Clear state
        isAuthenticated = false
        currentUser = nil
        authState = .idle
        
        #if DEBUG
        print("‚úÖ All authentication data cleared")
        #endif
    }
    
    // MARK: - Force Refresh Auth State
    
    func forceRefreshAuthState() {
        #if DEBUG
        print("üîÑ Force refreshing authentication state...")
        #endif
        
        checkAuthenticationState()
    }
    
    // MARK: - App Lifecycle Monitoring
    
    private func setupAppLifecycleMonitoring() {
        // Monitor app lifecycle events
        NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)
            .sink { [weak self] _ in
                Task { @MainActor in
                    await self?.handleAppWillEnterForeground()
                }
            }
            .store(in: &cancellables)
        
        NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)
            .sink { [weak self] _ in
                Task { @MainActor in
                    await self?.handleAppDidBecomeActive()
                }
            }
            .store(in: &cancellables)
    }
    
    private func handleAppWillEnterForeground() async {
        #if DEBUG
        print("üì± ===== APP WILL ENTER FOREGROUND =====")
        print("üì± Current state before validation:")
        print("üì±   - isAuthenticated: \(isAuthenticated)")
        print("üì±   - currentUser: \(currentUser?.email ?? "nil")")
        print("üì±   - authState: \(authState)")
        print("üì±   - hasAccessToken: \(accessToken != nil)")
        #endif
        
        await validateUserInDatabase()
    }
    
    private func handleAppDidBecomeActive() async {
        #if DEBUG
        print("üì± ===== APP DID BECOME ACTIVE =====")
        print("üì± Current state before validation:")
        print("üì±   - isAuthenticated: \(isAuthenticated)")
        print("üì±   - currentUser: \(currentUser?.email ?? "nil")")
        print("üì±   - authState: \(authState)")
        print("üì±   - hasAccessToken: \(accessToken != nil)")
        #endif
        
        await validateUserInDatabase()
    }
    
    // MARK: - User Database Validation
    
    /// Validates that the currently logged-in user still exists in the database
    /// This is called automatically on app lifecycle events
    func validateUserInDatabase() async {
        #if DEBUG
        print("üîç ===== VALIDATING USER IN DATABASE =====")
        print("üîç Validation conditions check:")
        print("üîç   - isAuthenticated: \(isAuthenticated)")
        print("üîç   - hasAccessToken: \(accessToken != nil)")
        print("üîç   - tokenNotEmpty: \(accessToken?.isEmpty == false)")
        print("üîç   - notAlreadyValidating: \(authState != .validatingUser)")
        #endif
        
        // Only validate if we think we're authenticated and have a token
        guard isAuthenticated, 
              let token = accessToken, 
              !token.isEmpty,
              authState != .validatingUser else {
            #if DEBUG
            print("‚è≠Ô∏è Skipping user validation:")
            if !isAuthenticated { print("‚è≠Ô∏è   - Reason: Not authenticated") }
            if accessToken == nil { print("‚è≠Ô∏è   - Reason: No access token") }
            if accessToken?.isEmpty == true { print("‚è≠Ô∏è   - Reason: Access token is empty") }
            if authState == .validatingUser { print("‚è≠Ô∏è   - Reason: Already validating") }
            print("‚è≠Ô∏è ===== VALIDATION SKIPPED =====")
            #endif
            return
        }
        
        authState = .validatingUser
        isValidatingUser = true
        
        #if DEBUG
        print("üîç Starting user validation...")
        print("üîç Making API call to /auth-direct/profile")
        #endif
        
        do {
            let apiRequest = APIRequest(
                method: .GET,
                path: "/auth-direct/profile"
            )
            
            let user: User = try await APIService.shared.send(
                apiRequest,
                responseType: User.self
            )
            
            #if DEBUG
            print("üîç ‚úÖ API call successful!")
            print("üîç User data received:")
            print("üîç   - ID: \(user.id)")
            print("üîç   - Email: \(user.email)")
            print("üîç   - Onboarding completed: \(user.onboardingCompleted)")
            #endif
            
            // User exists in database - update current user info
            currentUser = user
            userDefaults.set(user.id, forKey: KeychainKeys.userID)
            authState = .idle
            isValidatingUser = false
            
            #if DEBUG
            print("üîç ‚úÖ User validation successful: \(user.email)")
            print("üîç ===== VALIDATION SUCCESSFUL =====")
            #endif
            
        } catch {
            #if DEBUG
            print("üîç ‚ùå ===== VALIDATION FAILED =====")
            print("üîç Error details:")
            print("üîç   - Error type: \(type(of: error))")
            print("üîç   - Error description: \(error.localizedDescription)")
            print("üîç   - Full error: \(error)")
            print("üîç üö™ User no longer exists in database - logging out...")
            #endif
            
            // User doesn't exist in database or other error - force logout
            await logout()
            
            #if DEBUG
            print("üîç ‚ùå ===== VALIDATION FAILED - LOGGED OUT =====")
            #endif
        }
    }
    
    /// Manual validation that can be called from UI (e.g., refresh button)
    /// Forces validation even if one is already in progress
    func forceValidateUserInDatabase() async {
        #if DEBUG
        print("üîÑ Force validating user in database...")
        #endif
        
        guard let token = accessToken, !token.isEmpty else {
            #if DEBUG
            print("‚ùå No access token for force validation")
            #endif
            await logout()
            return
        }
        
        authState = .validatingUser
        isValidatingUser = true
        
        do {
            let apiRequest = APIRequest(
                method: .GET,
                path: "/auth-direct/profile"
            )
            
            let user: User = try await APIService.shared.send(
                apiRequest,
                responseType: User.self
            )
            
            // User exists in database - update current user info
            isAuthenticated = true
            currentUser = user
            userDefaults.set(user.id, forKey: KeychainKeys.userID)
            authState = .idle
            isValidatingUser = false
            
            #if DEBUG
            print("‚úÖ Force user validation successful: \(user.email)")
            #endif
            
        } catch {
            #if DEBUG
            print("‚ùå Force user validation failed: \(error)")
            print("üö™ User no longer exists in database - logging out...")
            #endif
            
            // User doesn't exist in database or other error - force logout
            await logout()
        }
    }
    
    // MARK: - User Profile
    
    private func fetchUserProfile() async {
        #if DEBUG
        print("üë§ ===== FETCHING USER PROFILE =====")
        print("üë§ Starting profile fetch...")
        #endif
        
        do {
            let apiRequest = APIRequest(
                method: .GET,
                path: "/auth-direct/profile"
            )
            
            #if DEBUG
            print("üë§ Making API request to: /auth-direct/profile")
            #endif
            
            let user: User = try await APIService.shared.send(
                apiRequest,
                responseType: User.self
            )
            
            #if DEBUG
            print("üë§ ‚úÖ API call successful!")
            print("üë§ User data received:")
            print("üë§   - ID: \(user.id)")
            print("üë§   - Email: \(user.email)")
            print("üë§   - Onboarding completed: \(user.onboardingCompleted)")
            #endif
            
            // Only set authenticated if we successfully fetched the user
            isAuthenticated = true
            currentUser = user
            userDefaults.set(user.id, forKey: KeychainKeys.userID)
            
            #if DEBUG
            print("üë§ ‚úÖ User profile fetched successfully, setting authenticated = true")
            print("üë§ ===== USER PROFILE FETCH COMPLETE =====")
            #endif
            
        } catch {
            #if DEBUG
            print("üë§ ‚ùå ===== USER PROFILE FETCH FAILED =====")
            print("üë§ Error details:")
            print("üë§   - Error type: \(type(of: error))")
            print("üë§   - Error description: \(error.localizedDescription)")
            print("üë§   - Full error: \(error)")
            #endif
            
            // Clear authentication state on profile fetch failure
            isAuthenticated = false
            currentUser = nil
            authState = .error(error.localizedDescription)
            
            #if DEBUG
            print("üë§ ‚ùå Cleared authentication state due to profile fetch failure")
            print("üë§ ===== USER PROFILE FETCH FAILED =====")
            #endif
        }
    }
    
    // MARK: - Private Helpers
    
    private func handleSuccessfulAuth(_ response: AuthResponse) async {
        // Store tokens
        userDefaults.set(response.accessToken, forKey: KeychainKeys.accessToken)
        if let refreshToken = response.refreshToken {
            userDefaults.set(refreshToken, forKey: KeychainKeys.refreshToken)
        }
        
        // Update state
        isAuthenticated = true
        currentUser = response.user
        authState = .idle
        
        if let user = response.user {
            userDefaults.set(user.id, forKey: KeychainKeys.userID)
        }
        
        #if DEBUG
        print("‚úÖ Authentication successful")
        #endif
    }
}

// MARK: - Request/Response Models

private struct AppleAuthRequest: Codable {
    let identityToken: String
    let authorizationCode: String
    let fullName: PersonNameComponents?
    let email: String?
}

private struct GoogleAuthRequest: Codable {
    let idToken: String
    let accessToken: String
}

private struct RefreshTokenRequest: Codable {
    let refreshToken: String
}

private struct AuthResponse: Codable {
    let accessToken: String
    let refreshToken: String?
    let user: User?
    
    enum CodingKeys: String, CodingKey {
        case accessToken = "access_token"
        case refreshToken = "refresh_token"
        case user
    }
}

// MARK: - Auth Errors

enum AuthError: LocalizedError {
    case noPresentingViewController
    case googleSignInFailed
    case noGoogleIDToken
    case noRefreshToken
    case appleSignInCancelled
    case appleSignInFailed
    
    var errorDescription: String? {
        switch self {
        case .noPresentingViewController:
            return "Unable to present sign-in view"
        case .googleSignInFailed:
            return "Google Sign-In failed"
        case .noGoogleIDToken:
            return "Failed to get Google ID token"
        case .noRefreshToken:
            return "No refresh token available"
        case .appleSignInCancelled:
            return "Apple Sign-In was cancelled"
        case .appleSignInFailed:
            return "Apple Sign-In failed"
        }
    }
}

